---
title: "Factors - handling categorical data"
output: html_notebook
---

# Data
We are now changing to a new dataset: melanoma. Remember to Restart your R session to clear up the Environment from the previous session.

```{r, message = FALSE}
library(tidyverse)
library(finalfit)
library(broom)
mydata = boot::melanoma

```

Click on mydata in your Environment and have a look at the values - you'll see that categorical variables are coded as numbers, rather than text. You will need to recode these numbers into proper factors. 



## Recap on factors

Press F1 on `boot::melanoma` to see its description. Use the information from help to change the numbers (e.g. 0 - female, 1 - male) into proper factors. In the first example we create a new variable called `status.factor` by converting `status` into a factor and then moving "Alive" to the front (the final order is then "Alive", "Died", "Died - other causes"). This means that the odds ratio will be relative to "Alive".

```{r}

mydata = mydata %>% 
  mutate(status.factor = status %>% 
           factor() %>% 
           fct_recode("Died"  = "1",
                      "Alive" = "2",
                      "Died - other causes" = "3") %>% 
           fct_relevel("Alive"))
  

mydata = mydata %>%
  mutate(sex.factor = sex %>% 
           factor() %>% 
           fct_recode("Female" = "0",
                      "Male" = "1"))
  
mydata = mydata %>%
  mutate(ulcer.factor = ulcer %>% 
           factor() %>% 
           fct_recode("Present" = "1",
                      "Absent"  = "0"))

#the cut() function makes a continuous variable into a categorical variable
mydata = mydata %>%
  mutate(age.factor = age %>% 
           cut(breaks = c(4,20,40,60,95), include.lowest=TRUE))

```

# Save the recoded tibble as an `.rda` file

Previously, we have shown you how to write data back out from R into a spreadsheet (`write_csv()`). But when you read in a spreadsheet, it will not know which variables are factors, and which just plain characters. And therefore, it won't know which order to plot the factors in - you will have to reapply the `fct_relevel()` line.

For saving tibbles as `.rda` (R data) files, we do:

```{r}
save(mydata, file = here::here("melanoma_recoded_20190510.rda"))
```

Remember: `.rda` files are read in using load: 

```{r}
load(here::here("melanoma_recoded_20190510.rda"))
```

Whereas spreadsheets (or formats from other stats packages) are read:

```{r, eval = FALSE}
read_csv(here::here("global_burden_disease_short.csv"))
```


## Plotting
Always plot new data first!

```{r, fig.width=4, fig.height=3}

mydata %>% 
  ggplot(aes(x = ulcer.factor, fill=status.factor)) + 
  geom_bar(position = "fill") +
  theme_bw() +
  scale_fill_brewer(palette = "Paired")

```

```{r, fig.width=6, fig.height=3}
mydata %>% 
  ggplot(aes(x = age.factor, fill = status.factor)) +
  geom_bar() +
  theme_bw() +
  scale_fill_brewer(palette = "Paired")
```

```{r, fig.width=6, fig.height=3}
mydata %>% 
  ggplot(aes(x = ulcer.factor, fill=status.factor)) + 
  geom_bar() +
  theme_bw() +
  scale_fill_brewer(palette = "Paired") +
  facet_grid(sex.factor~age.factor)
```

## Analysis

### Using base R

First lets group together those that 'died of another cause' with those 'alive', to give a disease-specific mortality variable (`fct_collapse` will help us) . 
```{r}

mydata = mydata %>%
  mutate(status.factor = status.factor %>% 
	fct_collapse("Alive" = c("Alive", "Died - other causes")))

```

Let's test mortality against sex.

```{r}

table(mydata$status.factor, mydata$sex.factor)
chisq.test(mydata$status.factor, mydata$sex.factor)

```

Note that `chisq.test()` defaults to the Yates continuity correction. It is fine to use this, but if you have a particular need not to, turn if off with `chisq.test(mydata$status.factor, mydata$sex.factor, correct=FALSE)`.

## Summarising factors with `library(finalfit)`

* Our own package
* Contains functions to summarise data for publication tables and figures
* Easily run regression analyses.  


```{r}

library(finalfit)

# F1 summary_factorlist to see options
mydata %>% 
  summary_factorlist(dependent = "status.factor", 
                     explanatory = "sex.factor",
                     p = TRUE,
                     column = TRUE)

```



```{r}

mydata %>% 
  summary_factorlist(dependent = "status.factor", 
                     explanatory = "age.factor",
                     p = TRUE,
                     column = TRUE)

```

----

`finalfit` also works with continuous variables


```{r}

mydata %>% 
  summary_factorlist(dependent = "status.factor", 
                     explanatory = "thickness",
                     p = TRUE,
                     column = TRUE)

```



## Summarising multiple factors

`finalfit` is useful for summarising multiple variables. We often want to summarise more than one factor or continuous variable against our `dependent` variable of interest. Think of Table 1 in a journal article. 

Here is a quick way of doing so using our `finalfit` package.



```{r, message = FALSE}

mydata %>% 
  summary_factorlist(dependent = "status.factor", 
                     explanatory = c("sex.factor", "thickness"),
                     p = TRUE,
                     column = TRUE)

```



## Summarising factors with `library(tidyverse)`

### Example
`Tidyverse` gives the flexibility and power to examine millions of rows of your data any way you wish. The following are intended as an extension to what you have already done. These demonstrate some more advanced approaches to combining `tidy` functions. 

```{r}

# Calculate number of patients in each group
counted_data = mydata %>%
  count(ulcer.factor, status.factor)

# Add the total number of people in each status group
counted_data2 = counted_data %>%
  group_by(status.factor) %>%
  mutate(total = sum(n))   

```

```{r}

# Calculate the percentage of n to total
counted_data3 = counted_data2 %>%
  mutate(percentage = round(100*n/total, 1))

```

```{r}

# Create a combined columns of both n and percentage,
# using paste to add brackets around the percentage
counted_data4 = counted_data3 %>% 
  mutate(count_perc = paste0(n, " (", percentage, ")"))

```


Or combine everything together without the intermediate `counted_data` breaks.
```{r}

mydata %>%
  count(ulcer.factor, status.factor) %>%
  group_by(status.factor) %>%
  mutate(total = sum(n)) %>%
  mutate(percentage = round(100*n/total, 1)) %>% 
  mutate(count_perc = paste0(n, " (", percentage, ")")) %>% 
  select(-total, -n, -percentage) %>% 
  spread(status.factor, count_perc)

```



## Exercise 6.1

Using `finalfit` create a summary table with "status.factor" as the dependent variable and the following as explanatory variables:  

* `sex.factor`  
* `ulcer.factor`  
* `age.factor`   
* `thickness`   



Try changing the table to show `median` and `interquartile range` instead of mean and sd.  



## Exercise 6.2
By changing one and only one line in the following block create firstly a new table showing the breakdown of `status.factor` by age and secondly the breakdown of `status.factor` by sex:

```{r, eval=FALSE}

mydata %>%
  count(ulcer.factor, status.factor) %>%
  group_by(status.factor) %>%
  mutate(total = sum(n)) %>%
  mutate(percentage = round(100*n/total, 1)) %>% 
  mutate(count_perc = paste0(n, " (", percentage, ")")) %>% 
  select(-total, -n, -percentage) %>% 
  spread(status.factor, count_perc)

```




## Exercise 6.3
Now produce these tables using the `summary_factorlist` function from the `library(finalfit)` package. 


## Exercise 6.4
Reproduce the plot from 6.1 but this time with row-wise percentages instead of col(column)-wise percentages.